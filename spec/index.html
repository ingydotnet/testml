<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <title>TestML - Testing Meta Language</title>
    <link href="../css/general.css" rel="stylesheet" type="text/css">
  <head>
  <body>



<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#testml">TestML</a></li>
	<li><a href="#status">Status</a></li>
	<li><a href="#overview">Overview</a></li>
	<li><a href="#history">History</a></li>
	<li><a href="#design_goals">Design Goals</a></li>
	<li><a href="#terminology">Terminology</a></li>
	<li><a href="#the_specification">The Specification</a></li>
	<ul>

		<li><a href="#grammar_operators_and_primitives">Grammar Operators and Primitives</a></li>
		<li><a href="#top_level_document_grammar">Top Level Document Grammar</a></li>
		<li><a href="#testml_data_section_grammar">TestML Data Section Grammar</a></li>
		<li><a href="#testml_document_constraints">TestML Document Constraints</a></li>
		<ul>

			<li><a href="#document_encoding">Document Encoding</a></li>
			<li><a href="#valid_meta_keywords">Valid Meta Keywords</a></li>
			<li><a href="#include_files">Include Files</a></li>
		</ul>

	</ul>

	<li><a href="#authors">Authors</a></li>
	<li><a href="#license">License</a></li>
	<li><a href="#copyright">Copyright</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="testml">TestML</a></h1>
<p>A Software Testing Meta Language. Version 1.0.</p>
<p>
</p>
<hr />
<h1><a name="status">Status</a></h1>
<p>Working Draft - 10 May, 2009</p>
<p>This document is not the final 1.0 release. It is very new, under
review, and undergoing initial implementation and testing.</p>
<p>
</p>
<hr />
<h1><a name="overview">Overview</a></h1>
<p><strong>TestML</strong> is a meta language for writing tests that define how a piece
of software should behave, regardless of the programming language the
software is written in.</p>
<p>It is primarily intended for generic libraries or modules that are
relevant in many languages, or that have multiple implementations in the
same language. In these scenarios the different implementations can all
use the exact same tests. However, TestML's clarity and ease of use may
make it desirable for testing all types of software.</p>
<p>TestML documents define a set of data points and an abstract set of
transforms that invoke the application being tested. The transforms
alter given data points into new states. Then assertions can be made
between the altered data points and expected result data points. Here is
a simple example:</p>
<pre>
    testml: 1.0
    input.uppercase() == output
    === Test mixed case string
    --- input: I Like Pie
    --- output: I LIKE PIE
    === Test lower case string
    --- input: i love lucy
    --- output: I LOVE LUCY</pre>
<p>In this case, a programmer of any given language would do the following:</p>
<ul>
<li><strong><a name="implement_a_library_foo_that_can_turn_strings_to_upper_case" class="item">Implement a library &quot;Foo&quot; that can turn strings to upper case.</a></strong>

<li><strong><a name="implement_a_testml_bridge_class_that_defines_the_uppercase_transform_to_invoke_the_foo_library_s_upper_casing_facility" class="item">Implement a TestML &quot;bridge class&quot; that defines the 'uppercase'
transform to invoke the Foo library's upper casing facility.</a></strong>

<li><strong><a name="set_up_their_test_environment_to_use_testml_to_run_the_test" class="item">Set up their test environment to use TestML to run the test.</a></strong>

</ul>
<p>
</p>
<hr />
<h1><a name="history">History</a></h1>
<p>The concept of TestML was heavily inspired by Ward Cunningham's <strong>FIT</strong>
test framework. The primary difference is that FIT's test documents are
table/spreadsheet based, where TestML's are text file based. This belies
the premise that FIT caters to business application development (where
spreadsheets are heavily used), while TestML caters to open source
library authors (where everything is in text files).</p>
<p>The specifics of TestML, and the data format specifically, evolved
directly from Ingy döt Net's data-driven Perl testing framework,
<strong>Test::Base</strong>. Test::Base was written in 2004 and later ported to
JavaScript. As Ingy ported various libraries to other languages, he
realized the potential value of having the test suites be reusable.</p>
<p>
</p>
<hr />
<h1><a name="design_goals">Design Goals</a></h1>
<p>TestML has the following Design Goals:</p>
<dl>
<dt><strong><a name="platform_agnostic" class="item">Platform Agnostic</a></strong>

<dd>
<p>TestML strives to make no assumptions about the programming language,
environment, or testing framework it will be used in. In this way, the
same corpus of test documents can be used against multiple
implementations of equivalent software.</p>
</dd>
</li>
<dt><strong><a name="readability" class="item">Readability</a></strong>

<dd>
<p>TestML lets you define tests that are easy for both you and others to
write, read and maintain. The format is intended to let the data points
and test conditions stand out, while hiding the details of
implementation in the <em>bridge class</em>.</p>
</dd>
</li>
<dt><strong><a name="extensibility" class="item">Extensibility</a></strong>

<dd>
<p>TestML has been designed with acknowledgement that it will need to
evolve to meet many various testing requirements. For this reason, every
document requires a TestML version number. Also the original grammar has
been made quite strict, leaving a lot of room for future extension.</p>
</dd>
</li>
<dt><strong><a name="ease_of_implementation" class="item">Ease of Implementation</a></strong>

<dd>
<p>TestML is designed to be fairly easy to implement in various programming
languages.</p>
</dd>
<dd>
<p>The TestML project has a set of tests (written in TestML) that a TestML
implementation must pass to be compliant. See <a href="http://testml.org/tests/">http://testml.org/tests/</a>.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="terminology">Terminology</a></h1>
<p>TestML uses a number of specific terms. The following glossary lists the 
terms and defines their meanings.</p>
<dl>
<dt><strong><a name="application" class="item">Application</a></strong>

<dd>
<p>The software that is being tested.</p>
</dd>
</li>
<dt><strong><a name="assertion" class="item">Assertion</a></strong>

<dd>
<p>A <em>test assertion</em> is a statement in the <em>TestML document</em> that
compares two <em>data points</em> using a <em>testing operator</em>, after they have
been passed through a set of <em>data transforms</em>.</p>
</dd>
</li>
<dt><strong><a name="block" class="item">Block</a></strong>

<dd>
<p>A <em>data block</em> is an object that contains a set of named <em>data
points</em>. The block usually has a short label phrase. When the
tests are run, the <em>runner class</em> will run each of the <em>test
assertions</em> against each of the <em>data blocks</em> that contain the <em>data
points</em> needed by the assertion.</p>
</dd>
</li>
<dt><strong><a name="bridge" class="item">Bridge</a></strong>

<dd>
<p>Every test setup defines a class that connects named <em>data transforms</em>
to the software being tested. This is known as a <em>bridge class</em>,
because it bridges the test to the application or library.</p>
</dd>
</li>
<dt><strong><a name="document" class="item">Document</a></strong>

<dd>
<p>A <em>TestML document</em> is a file containing some number of <em>test
assertions</em> and <em>data blocks</em>. This specification describes the format
of such a document.</p>
</dd>
</li>
<dt><strong><a name="expression" class="item">Expression</a></strong>

<dd>
<p>A <em>data expression</em> is a <em>data point</em> name followed by zero or more
calls to named <em>data transforms</em>.</p>
</dd>
<dd>
<p>A <em>test assertion</em> compares the result of two data expressions.</p>
</dd>
</li>
<dt><strong><a name="meta" class="item">Meta</a></strong>

<dd>
<p>A <em>TestML document</em> can define a number of key/value pairs which are
considered <em>meta data</em> and are used to instantiate a <em>meta object</em>
that the test code can later access.</p>
</dd>
</li>
<dt><strong><a name="operator" class="item">Operator</a></strong>

<dd>
<p>A <em>testing operator</em> is a method that compares the final state of two
data points. The only operator currently defined by TestML is the '=='
operator, which compares two unicode strings for an exact match.</p>
</dd>
</li>
<dt><strong><a name="point" class="item">Point</a></strong>

<dd>
<p>A <em>data point</em> is a named piece of data that belongs to a given <em>data
block</em>. All data points are assumed to start out as unicode strings,
although a <em>data transform</em> may turn them into anything else.</p>
</dd>
</li>
<dt><strong><a name="runner" class="item">Runner</a></strong>

<dd>
<p>The TestML class that is responsible for running all the
appropriate tests.</p>
</dd>
</li>
<dt><strong><a name="section" class="item">Section</a></strong>

<dd>
<p>Every <em>TestML document</em> has two sections, a <em>head section</em> and a
<em>data section</em>. The former specifies <em>meta information</em> and the <em>test
assertions</em> that the document is declaring. The latter section defines
the <em>data blocks</em> against which the test assertions are applied.</p>
</dd>
</li>
<dt><strong><a name="transform" class="item">Transform</a></strong>

<dd>
<p>A <em>transform</em> is a method provided by a <em>bridge class</em> that changes a
<em>data point</em> form one form into another. A transform usually invokes
functionality of the <em>application</em> it is testing. The whole idea of
TestML is that by passing a data point through one or more transforms,
you can make it equivalent to some other data point, which causes the
test to pass.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="the_specification">The Specification</a></h1>
<p>To simplify the TestML Specification, it is defined as both a <em>set of
BNF grammars</em>, and a <em>set of constraints</em>. The grammars include a <em>top
level document grammar</em> and a separate <em>TestML data section grammar</em>.
The data section is separate, because it may be marked up in any of
several syntaxes.</p>
<p>
</p>
<h2><a name="grammar_operators_and_primitives">Grammar Operators and Primitives</a></h2>
<p>This is a list of the special characters used in the grammars. They are
mostly borrowed from the PCRE regexp standard.</p>
<ul>
<li><strong><a name="alternation" class="item">'|' - Alternation</a></strong>

<li><strong><a name="exclusion" class="item">'-' - Exclusion</a></strong>

<li><strong><a name="zero_or_more" class="item">'*' - Zero or more</a></strong>

<li><strong><a name="one_or_more" class="item">'+' - One or more</a></strong>

<li><strong><a name="zero_or_one" class="item">'?' - Zero or one</a></strong>

<li><strong><a name="parentheses_indicate_grouping" class="item">'(...)' - Parentheses indicate grouping</a></strong>

</ul>
<p>The following primitives are defined in terms of their PCRE regexp
equivalents.</p>
<p>NOTE: There is a premise that only printable characters are allowed in a
      TestML document stream. The primitives therefore implicitly
      exclude control characters and such.</p>
<ul>
<li><strong><a name="any_s_s_any_unicode_character" class="item">ANY - '[\s\S]' - Any unicode character</a></strong>

<li><strong><a name="space_t_a_space_or_tab_character" class="item">SPACE - '[\ \t]' - A space or tab character</a></strong>

<li><strong><a name="break_n_a_newline_character" class="item">BREAK - '\n' - A newline character</a></strong>

<li><strong><a name="eol_r_n_a_unix_or_dos_line_ending" class="item">EOL - '\r?\n' - A Unix or DOS line ending</a></strong>

<li><strong><a name="non_space_s_a_non_space_character" class="item">NON-SPACE - '\S' - A non-space character</a></strong>

<li><strong><a name="non_break_any_character_except_newline" class="item">NON-BREAK - '.' - Any character except newline</a></strong>

<li><strong><a name="alpha_a_za_z_ascii_alphabetic_character" class="item">ALPHA - '[A-Za-z]' - ASCII alphabetic character</a></strong>

<li><strong><a name="alphanum_a_za_z0_9_ascii_alpha_numeric_character" class="item">ALPHANUM - '[A-Za-z0-9]' - ASCII alpha numeric character</a></strong>

<li><strong><a name="word_w_ie_a_za_z0_9_a_word_character" class="item">WORD - '\w' - ie '[A-Za-z0-9_]' - A &quot;word&quot; character</a></strong>

<li><strong><a name="back_a_backslash_character" class="item">BACK - '\' - A backslash character</a></strong>

<li><strong><a name="single_a_single_quote_character" class="item">SINGLE - &quot;'&quot; - A single quote character</a></strong>

<li><strong><a name="double_a_double_quote_character" class="item">DOUBLE - '&quot;' - A double quote character</a></strong>

<li><strong><a name="escape_0abenrtz_one_of_the_escapable_character_ids" class="item">ESCAPE - '[0abenrtz]' - One of the escapable character IDs</a></strong>

</ul>
<p>
</p>
<h2><a name="top_level_document_grammar">Top Level Document Grammar</a></h2>
<dl>
<dt><strong><a name="document_head_section_data_section" class="item">document := head-section data-section</a></strong>

<dd>
<p>A TestML Document consists of 2 sections, a head section followed by a data section.</p>
</dd>
<dd>
<p>Here is an example document:</p>
</dd>
<dd>
<pre>
    # TestML document head section includes:
    # Meta statements,
    testml: 1.0
    key1: value1
    # And test assertions.
    foo.upper() == bar
    foo == bar.lower()</pre>
</dd>
<dd>
<pre>
    # The data section defines data objects.
    === Test vowels
    --- foo: i ie ie
    --- bar: I IE IE
    === Test consonants
    --- foo
    lk p
    --- bar
    LK P</pre>
</dd>
</li>
<dt><strong><a name="head_section_meta_statement_test_statement_include_statements_comment_blank_line" class="item">head-section := ( meta-statement | test-statement | include-statements | comment | blank-line )+</a></strong>

<dd>
<p>The head section contains both general information (meta statements)
about the test document and the definitions of the assertions the test
is declaring (test statements).</p>
</dd>
<dd>
<p>The parsing of the head section should instantiate two TestML objects:
the Meta object and the Tests object.</p>
</dd>
</li>
<dt><strong><a name="meta_statement_keyword_space_value_eol" class="item">meta-statement := keyword ':' SPACE+ value EOL</a></strong>

<dd>
<p>Meta statements are key/value pairs separated by a colon and a
SPACE. A given meta setting may affect the document parsing from
that point forward.</p>
</dd>
</li>
<dt><strong><a name="keyword_word" class="item">keyword := WORD*</a></strong>

<dd>
<p>A keyword is the name of a meta setting. See Constraints for the
valid values.</p>
</dd>
</li>
<dt><strong><a name="space" class="item">value := NON-SPACE (NON-BREAK* NON-SPACE)?</a></strong>

<dd>
<p>A value is a non blank, non empty, single line phrase of characters.</p>
</dd>
</li>
<dt><strong><a name="test_statement_data_expression_space_operator_space_data_expression_eol" class="item">test-statement := data-expression SPACE+ operator SPACE+ data-expression EOL</a></strong>

<dd>
<p>A test statement is a declaration of a testing operation. A typical
statement looks like:</p>
</dd>
<dd>
<pre>
    input-point.transform1().transform2(arguments) == expected-output-point</pre>
</dd>
</li>
<dt><strong><a name="data_expression_point_name_transform_call" class="item">data-expression := point-name transform-call*</a></strong>

<dd>
<p>A data transform is a data point name followed by zero or more data
transform calls.</p>
</dd>
</li>
<dt><strong><a name="point_name_alpha_word" class="item">point-name := ALPHA WORD*</a></strong>

<dd>
<p>A point name is the name of a data point defined in the data section of
the document.</p>
</dd>
</li>
<dt><strong><a name="transform_call_transform_name_argument_list" class="item">transform-call := '.' transform-name '(' argument-list ')'</a></strong>

<dd>
<p>A transform call is like a method call in Python. A '.' invokes a named
transform/method with a list of arguments.</p>
</dd>
<dd>
<pre>
    .transform_name()</pre>
</dd>
</li>
<dt><strong><a name="transform_name_aplha_word" class="item">transform-name := APLHA WORD*</a></strong>

<dd>
<p>A transform name is a like a method name in a programming language.</p>
</dd>
<dd>
<pre>
    thisIsTheTransformName</pre>
</dd>
</li>
<dt><strong><a name="argument" class="item">argument-list := ( argument (',' SPACE argument)* )?</a></strong>

<dd>
<p>Currently the only thing allowed in an argument list is a list of
strings. The list can be empty and usually is.</p>
</dd>
</li>
<dt><strong><a name="argument_point_name_quoted_string" class="item">argument := point-name | quoted-string</a></strong>

<dd>
<p>An argument passed to a transform call can be a data point name or a
quoted string. If it is a point name, the original value of that data
point will be passed to the transform when the test is run.</p>
</dd>
</li>
<dt><strong><a name="quoted_string_single_quoted_string_double_quoted_string" class="item">quoted-string := single-quoted-string | double-quoted-string</a></strong>

<dd>
<p>A quoted string can use either single or double quotes.</p>
</dd>
</li>
<dt><strong><a name="single" class="item">single-quoted-string :=
    SINGLE ((ANY - (BREAK | BACK | SINGLE)) | BACK SINGLE | BACK BACK)* SINGLE</a></strong>

<dd>
<p>A single quoted string has Perl semantics. A backslash is used to encode
a backslash or a single quote character.</p>
</dd>
<dd>
<pre>
    .foo('Won\'t you scratch\\slash my back?')</pre>
</dd>
</li>
<dt><strong><a name="double" class="item">double-quoted-string :=
    DOUBLE ((ANY - (BREAK | BACK | DOUBLE)) |
    BACK DOUBLE | BACK BACK | BACK ESCAPE )* DOUBLE</a></strong>

<dd>
<p>A double quoted string has limited backslash escaping. You can encode a
backslash, double quote, newline or tab character.</p>
</dd>
<dd>
<pre>
    .bar(&quot;\tline 1\n\&quot;line\&quot; 2\n&quot;)</pre>
</dd>
</li>
<dt><strong><a name="statement" class="item">include-statements :=
    include-statement ( include-statement | comment | blank-line )*</a></strong>

<dd>
<p>A group of adjacent include statements is processed at once. All of the
files are included into the current document stream and then parsing
continues. Doing them as a group allows multiple files to be included in
the data section, where '%include' statements are no longer recognized.</p>
</dd>
</li>
<dt><strong><a name="include_statement_include_space_relative_file_path_eol" class="item">include-statement := '%include' SPACE relative-file-path EOL</a></strong>

<dd>
<p>An include statement causes the named relative file to be read. The file
contents replace the include statement and are immediately parsed.</p>
</dd>
<dd>
<p>The included file must end with a newline, unless the file is empty.</p>
</dd>
</li>
<dt><strong><a name="blank_line_space_eol" class="item">blank-line := SPACE* EOL</a></strong>

<dd>
<p>Blank lines are useful to space things out visually.</p>
</dd>
</li>
<dt><strong><a name="comment_line" class="item">comment := '#' line</a></strong>

<dd>
<p>A comment is a line that begins with a '#'. A '#' anywhere else on a
line will not start a comment.</p>
</dd>
</li>
<dt><strong><a name="data_section_testml_data_section_yaml_data_section_json_data_section_xml_data_section" class="item">data-section := testml-data-section | yaml-data-section | json-data-section | xml-data-section</a></strong>

<dd>
<p>The data section defines a sequence of data objects, each of which
consists of a short label phrase and a set of named data points.</p>
</dd>
<dd>
<p>TestML defines a default syntax, but this section can also be specified
in YAML, JSON or XML.</p>
</dd>
</li>
<dt><strong><a name="marker" class="item">testml-data-section := testml-data-block-marker (SPACE | EOL) rest</a></strong>

<dd>
<p>The <em>TestML data section</em> starts when the data block marker is detected
at the beginning of a line and continues to the end of the file. This
section is parsed into <em>data block</em> objects.</p>
</dd>
<dd>
<p>Here is an example data section in TestML:</p>
</dd>
<dd>
<pre>
    === Test one
    --- input: abc
    --- output: 123
    === Test two
    --- input: xyz
    --- output: 321</pre>
</dd>
<dd>
<p>See <a href="#testml_data_section_grammar">TestML Data Section Grammar</a> for the more formal syntax grammar of
this format.</p>
</dd>
</li>
<dt><strong><a name="yaml_data_section_space_eol_rest" class="item">yaml-data-section :=  '---' (SPACE | EOL) rest</a></strong>

<dd>
<p>Here is an example data section in YAML:</p>
</dd>
<dd>
<pre>
    ---
    - -label: Test one
      input: abc
      output: 123
    - -label: Test two
      input: xyz
      output: 321</pre>
</dd>
</li>
<dt><strong><a name="json_data_section_rest" class="item">json-data-section :=  '[' rest</a></strong>

<dd>
<p>Here is an example data section in JSON:</p>
</dd>
<dd>
<pre>
    [
      {
        &quot;-label: &quot;Test one&quot;,
        &quot;input&quot;: &quot;abc&quot;,
        &quot;output&quot;: &quot;123&quot;
      },
      {
        &quot;-label: &quot;Test two&quot;,
        &quot;input&quot;: &quot;xyz&quot;,
        &quot;output&quot;: &quot;321&quot;
      }
    ]</pre>
</dd>
</li>
<dt><strong><a name="xml_data_section_rest" class="item">xml-data-section :=  '&lt;' rest</a></strong>

<dd>
<pre>
    &lt;testml&gt;
      &lt;block label=&quot;Test one&quot;&gt;
        &lt;input&gt;abc&lt;/input&gt;
        &lt;output&gt;123&lt;/output&gt;
      &lt;/block&gt;
      &lt;block label=&quot;Test two&quot;&gt;
        &quot;input&quot;: &quot;xyz&quot;,
        &quot;output&quot;: &quot;321&quot;
      &lt;/block&gt;
    &lt;/testml&gt;</pre>
</dd>
<dt><strong><a name="rest_any" class="item">rest := ANY+</a></strong>

<dd>
<p>The <em>rest</em> token is simply the remainder of the text in the file.
The <em>data sections</em> are all parsed by separate parsers/grammars.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="testml_data_section_grammar">TestML Data Section Grammar</a></h2>
<p>This grammar defines the TestML data section markup.</p>
<dl>
<dt><strong><a name="data_section_data_block" class="item">data-section := data-block*</a></strong>

<dd>
<p>A data section consists of 0-n data blocks.</p>
</dd>
</li>
<dt><strong><a name="header" class="item">data-block := block-header (blank-line | comment)* data-point*</a></strong>

<dd>
<p>A data block in TestML syntax looks like:</p>
</dd>
<dd>
<pre>
    === Block Label
    --- point1: phrase data
    --- point2
    line
    data</pre>
</dd>
</li>
<dt><strong>block-header := block-marker (SPACE block-label)? SPACE* EOL</strong>

<dd>
<p>A block header marks the start of a new block. The first one also marks
the start of the data section. It contains an optional label.</p>
</dd>
<dd>
<pre>
    === The next big test</pre>
</dd>
</li>
<dt><strong><a name="block_marker_meta_testml_block_marker" class="item">block-marker := '===' | meta.testml_block_marker</a></strong>

<dd>
<p>A block marker is usually <code>===</code>, but it is configurable via a meta
statement, like this:</p>
</dd>
<dd>
<pre>
    testml_block_marker: ***</pre>
</dd>
</li>
<dt><strong><a name="data_point_lines_point_phrase_point" class="item">data-point := lines-point | phrase-point</a></strong>

<dd>
<p>Data points are the pieces of raw data that TestML transforms and
compares. They come in two flavors, lines and phrases.</p>
</dd>
</li>
<dt><strong><a name="lines_point_point_marker_point_name_space_eol_line" class="item">lines-point := point-marker point-name SPACE* EOL line*</a></strong>

<dd>
<p>A &quot;lines&quot; data point is a string containing zero or more lines. If it
has one or more lines it always ends with a newline.</p>
</dd>
<dd>
<pre>
    --- lines
    line1
    line2 (3 is blank)
    
    line4</pre>
</dd>
</li>
<dt><strong><a name="phrase_point_point_marker_point_name_space_non_break_eol_blank_line" class="item">phrase-point := point-marker point-name ':' SPACE NON-BREAK* EOL blank-line*</a></strong>

<dd>
<p>A &quot;phrase&quot; data point is a string with no newlines.</p>
</dd>
<dd>
<pre>
    --- phrase: This string is one line with no newline at the end.</pre>
</dd>
</li>
<dt><strong><a name="point_marker_meta_testml_point_marker" class="item">point-marker := '---' | meta.testml_point_marker</a></strong>

<dd>
<p>A point marker is usually <code>---</code>, but it is configurable via a meta
statement, like this:</p>
</dd>
<dd>
<pre>
    testml_point_marker: +++</pre>
</dd>
</li>
<dt><strong><a name="line_non_break_eol" class="item">line := NON-BREAK* EOL</a></strong>

<dd>
<p>A line is a string of zero or more non break characters followed by
a newline.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="testml_document_constraints">TestML Document Constraints</a></h2>
<p>The above grammars define the valid syntax for a TestML document, but
there is a also set of constraints that all TestML documents must
adhere to.</p>
<p>
</p>
<h3><a name="document_encoding">Document Encoding</a></h3>
<p>All TestML documents are composed of the printable unicode character set
and <em>must</em> be encoded in UTF8. Any character that does not meet these
requirements must cause an error.</p>
<p>
</p>
<h3><a name="valid_meta_keywords">Valid Meta Keywords</a></h3>
<p>If the parser detects a meta keyword that is not listed below, it must
cause an error.</p>
<dl>
<dt><strong><a name="testml_required" class="item">testml - <strong>required</strong></a></strong>

<dd>
<p>The <em>testml</em> meta statement is required and it must specify a version
number. The TestML implementation can then determine whether or not it
can process the document or not.</p>
</dd>
<dd>
<p>For example:</p>
</dd>
<dd>
<pre>
    testml: 1.0</pre>
</dd>
<dd>
<p>As a guideline, TestML will attempt to be backwards compatible with
version numbers that have the same first number. So version 1.3 would be
backwards compatible with 1.2, 1.1 and 1.0. Version 2.0 would probably
break compatability.</p>
</dd>
</li>
<dt><strong><a name="title_optional" class="item">title - <em>optional</em></a></strong>

<dd>
<p>The <em>title</em> meta option specifies a short title phrase to describe the
entire TestML document.</p>
</dd>
<dd>
<pre>
    title: These are a few of my Favorite Tests!</pre>
</dd>
<dd>
<p>The TestML implementation is free to use this meta field as it sees fit.</p>
</dd>
</li>
<dt><strong><a name="tests_optional" class="item">tests - <em>optional</em></a></strong>

<dd>
<p>The <em>tests</em> meta option specifies the expected number of tests that
will be run by the runner. If the actual number differs the
implementation may complain or throw an error.</p>
</dd>
<dd>
<pre>
    tests: 13</pre>
</dd>
</li>
<dt><strong><a name="testml_block_marker_optional" class="item">testml_block_marker - <em>optional</em></a></strong>

<dd>
<p>If you choose to use the TestML data markup to encode your data section,
you can choose the character sequence to replace the default ('===').
You would wnat to do this primarily if you had '===' at the beginning of
a line in your data.</p>
</dd>
<dd>
<p>Setting this option causes the parser to immediately start looking for
the specified pattern to indicate the start of the data section.</p>
</dd>
<dd>
<pre>
    testml_block_marker: *=*</pre>
</dd>
</li>
<dt><strong><a name="testml_point_marker_optional" class="item">testml_point_marker - <em>optional</em></a></strong>

<dd>
<p>This option is the same as the testml_block_marker option above, except
it is for the data point marker.</p>
</dd>
<dd>
<pre>
    testml_point_marker: +++</pre>
</dd>
</li>
</dl>
<p>
</p>
<h3><a name="include_files">Include Files</a></h3>
<p>Files are included by a relative path. If the file does not exist, and
thus can not be included, it must be considered an error. Recursive
inclusion must also be detected and cause an error.</p>
<p>
</p>
<hr />
<h1><a name="authors">Authors</a></h1>
<p>TestML Version 1.0 was created by Ingy döt Net &lt;<a href="mailto:ingy@ingy.net">ingy@ingy.net</a>&gt;</p>
<p>The spec was reviewed and/or contributed to by the following people:</p>
<ul>
<li><strong><a name="tony_bowden" class="item">Tony Bowden</a></strong>

<li><strong><a name="chris_dent" class="item">Chris Dent</a></strong>

<li><strong><a name="yuval_kogman" class="item">Yuval Kogman</a></strong>

</ul>
<p>
</p>
<hr />
<h1><a name="license">License</a></h1>
<p>This work is licensed under the Creative Commons Attribution Share Alike
License. To view a copy of this license, visit
<a href="http://creativecommons.org/licenses/by-sa/3.0/legalcode">http://creativecommons.org/licenses/by-sa/3.0/legalcode</a>;
or, (b) send a letter to Creative Commons, 171 2nd Street, Suite 300,
San Francisco, California, 94105, USA.</p>
<p>
</p>
<hr />
<h1><a name="copyright">Copyright</a></h1>
<p>Copyright (c) 2009. Ingy döt Net.</p>


  </body>
</html>

