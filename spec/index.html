<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html;charset=UTF-8" />
    <title>TestML - Testing Meta Language</title>
    <link href="../css/general.css" rel="stylesheet" type="text/css">
  <head>
  <body>



<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#testml">TestML</a></li>
	<li><a href="#status">Status</a></li>
	<li><a href="#overview">Overview</a></li>
	<li><a href="#history">History</a></li>
	<li><a href="#design_goals">Design Goals</a></li>
	<li><a href="#terminology">Terminology</a></li>
	<li><a href="#the_specification">The Specification</a></li>
	<ul>

		<li><a href="#top_level_document_grammar">Top Level Document Grammar</a></li>
		<li><a href="#testml_data_section_grammar">TestML Data Section Grammar</a></li>
	</ul>

	<li><a href="#authors">Authors</a></li>
	<li><a href="#copyright">Copyright</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="testml">TestML</a></h1>
<p>A Software Testing Meta Language. Version 1.0.</p>
<p>
</p>
<hr />
<h1><a name="status">Status</a></h1>
<p>Working Draft - 7 May, 2009</p>
<p>This document is not the final 1.0 release. It is very new and under
review.</p>
<p>
</p>
<hr />
<h1><a name="overview">Overview</a></h1>
<p><strong>TestML</strong> is a meta language for writing tests that define how a piece
of software should behave, regardless of what programming language that
software is written in.</p>
<p>It is primarily intended for generic libraries or modules that are
relevant in many languages, or that have multiple implementations in the
same language. In these scenarios, the different implementations all use
the exact same tests. However, TestML's clarity and ease of use may make
it desirable for testing all types of software.</p>
<p>TestML documents define a set of data points and a very abstract set of
transforms that invoke the application being tested to turn a given data
point into a form that matches the expected result point. Here is a very
simple example:</p>
<pre>
    testml: 1.0
    input.uppercase() == output
    === Test mixed case string
    --- input: I Like Pie
    --- output: I LIKE PIE</pre>
<p>In this case, a programmer of any given language would do the following:</p>
<ul>
<li><strong><a name="implement_a_library_foo_that_can_turn_strings_to_upper_case" class="item">Implement a library &quot;Foo&quot; that can turn strings to upper case.</a></strong>

<li><strong><a name="implement_a_testml_bridge_class_that_defines_the_uppercase_transform_to_invoke_the_foo_library_s_upper_casing_facility" class="item">Implement a TestML &quot;bridge class&quot; that defines the 'uppercase'
transform to invoke the Foo library's upper casing facility.</a></strong>

<li><strong><a name="set_up_their_test_environment_to_use_testml_to_run_the_test" class="item">Set up their test environment to use TestML to run the test.</a></strong>

</ul>
<p>
</p>
<hr />
<h1><a name="history">History</a></h1>
<p>The concept of TestML was heavily inspired by Ward Cunningham's <strong>FIT</strong>
test framework. The primary difference is that FIT's test documents are
table/spreadsheet based, where TestML's are text file based. This belies
the premise that FIT caters to business application development (where
spreadsheets are heavily used), and TestML caters to open source library
authors (where everything is in text files).</p>
<p>The specifics of TestML, and the data format specifically, evolved
directly from Ingy döt Net's Perl data-driven testing framework,
<strong>Test::Base</strong>. Test::Base was written in 2004 and later ported to
JavaScript. As Ingy ported various libraries to other languages, he
realized the potential value of having the test suites be reusable.</p>
<p>
</p>
<hr />
<h1><a name="design_goals">Design Goals</a></h1>
<p>TestML has the following Design Goals:</p>
<dl>
<dt><strong><a name="platform_agnostic" class="item">Platform Agnostic</a></strong>

<dd>
<p>TestML strives to make no assumptions about the programming language,
environment, or testing framework it will be used in. In this way, the exact
same corpus of test documents can be used against multiple implementations
of equivalent software.</p>
</dd>
</li>
<dt><strong><a name="readability" class="item">Readability</a></strong>

<dd>
<p>TestML lets you define tests that are both easy for you and others to
write, read and maintain. The format is intended to let the data points
and test conditions be very clear, while hiding the details of
implementation in the <em>bridge class</em>.</p>
</dd>
</li>
<dt><strong><a name="extensibility" class="item">Extensibility</a></strong>

<dd>
<p>TestML has been designed with the acknowledgement that it will need to
evolve to meet many various testing requirements. For this reason, every
document requires a TestML version number. Also the original grammar has
been made quite strict, leaving a lot of room for future extension.</p>
</dd>
</li>
<dt><strong><a name="ease_of_implementation" class="item">Ease of Implementation</a></strong>

<dd>
<p>TestML is designed to be fairly easy to implement in various programming
languages.</p>
</dd>
<dd>
<p>The TestML project has a set of tests (written in TestML) that a TestML
implementation must pass to be compliant. See <a href="http://testml.org/tests/">http://testml.org/tests/</a>.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="terminology">Terminology</a></h1>
<p>TestML uses a number of specific terms. This glossary lists and defines their
meanings.</p>
<dl>
<dt><strong><a name="application" class="item">Application</a></strong>

<dd>
<p>The software that is being tested.</p>
</dd>
</li>
<dt><strong><a name="assertion" class="item">Assertion</a></strong>

<dd>
<p>A <em>test assertion</em> is a statement in the <em>TestML document</em> that
compares two <em>data points</em> using a <em>testing operator</em>, after they have
been passed through a set of <em>data transforms</em>.</p>
</dd>
</li>
<dt><strong><a name="block" class="item">Block</a></strong>

<dd>
<p>A <em>data block</em> is an object that contains a set of named <em>data
points</em>. The block usually has a short description phrase. When the
tests are run, the <em>runner class</em> will run each of the <em>test
assertions</em> against each of the <em>data blocks</em> that contains the <em>data
points</em> needed by the assertion.</p>
</dd>
</li>
<dt><strong><a name="bridge" class="item">Bridge</a></strong>

<dd>
<p>Every test setup defines a class that connects named <em>data transforms</em>
to the software being tested. This is known as a <em>bridge class</em>,
because it bridges the test to the application or library.</p>
</dd>
</li>
<dt><strong><a name="document" class="item">Document</a></strong>

<dd>
<p>A <em>TestML document</em> is a file containing some number of <em>test
assertions</em> and <em>data blocks</em>. This specification describes the format
of such a document.</p>
</dd>
</li>
<dt><strong><a name="meta" class="item">Meta</a></strong>

<dd>
<p>A <em>TestML document</em> can define any number of key/value pairs which are
considered <em>meta data</em> and are used to instantiate a <em>meta object</em>
that the test code can later access.</p>
</dd>
</li>
<dt><strong><a name="operator" class="item">Operator</a></strong>

<dd>
<p>A <em>testing operator</em> is a method that compares the final state of
two data points. The only operator currently currently defined by
TestML is the '==' operator, which compares two unicode strings for
an exact match.</p>
</dd>
</li>
<dt><strong><a name="point" class="item">Point</a></strong>

<dd>
<p>A <em>data point</em> is a named piece of data that belongs to a given <em>data
block</em>. All data points are assumed to start out as unicode strings,
although a <em>data transform</em> may turn them into anything else.</p>
</dd>
</li>
<dt><strong><a name="runner" class="item">Runner</a></strong>

<dd>
<p>The TestML class that is responsible for running all the
appropriate tests.</p>
</dd>
</li>
<dt><strong><a name="section" class="item">Section</a></strong>

<dd>
<p>Every <em>TestML document</em> has two sections, a <em>head section</em> and a
<em>data section</em>. The former specifies <em>meta information</em> and the <em>test
assertions</em> that the document is declaring. The latter section defines
the <em>data blocks</em> against which the test assertions are applied.</p>
</dd>
</li>
<dt><strong><a name="transform" class="item">Transform</a></strong>

<dd>
<p>A <em>transform</em> is a method provided by a <em>bridge class</em> that changes a
<em>data point</em> form one form into another. A transform usually invokes
functionality of the application it is testing. The whole idea of
TestML is that by passing a data point through one or more transforms,
you can make it equivalent to some other data point, which causes the
test to pass.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="the_specification">The Specification</a></h1>
<p>To simplify the TestML Specification, it is defined as both a <em>set of
BNF grammars</em>, and a <em>set of constraints</em>. The grammars include a <em>top level
document grammar</em> and a separate <em>Testml data section grammar</em>. The data
section is separate, because it may be marked up in any of several syntaxes.</p>
<p>
</p>
<h2><a name="top_level_document_grammar">Top Level Document Grammar</a></h2>
<dl>
<dt><strong><a name="document_head_section_data_section" class="item">document := head-section data-section</a></strong>

<dd>
<p>A TestML Document consists of 2 sections, a head section followed by a data section.</p>
</dd>
<dd>
<p>Here is an example document:</p>
</dd>
<dd>
<pre>
    # TestML document head section includes:
    # Meta statements,
    testml: 1.0
    key1: value1
    # And test assertions.
    foo.upper() == bar
    foo == bar.lower()</pre>
</dd>
<dd>
<pre>
    # The data section defines data objects.
    === Test vowels
    --- foo: i ie ie
    --- bar: I IE IE
    === Test consonants
    --- foo
    lk p
    --- bar
    LK P</pre>
</dd>
</li>
<dt><strong><a name="head_section_meta_statement_test_statement_include_statement_comment_blank_line" class="item">head-section := ( meta-statement | test-statement | include-statement | comment | blank-line )+</a></strong>

<dd>
<p>The head section contains both general information (meta statements)
about the test document and the definitions of the assertions the test
is declaring (test statements).</p>
</dd>
<dd>
<p>The parsing of the head section should instantiate two TestML objects: the
Meta object and the Assertions object.</p>
</dd>
</li>
<dt><strong><a name="meta_statement_keyword_space_value_eol" class="item">meta-statement := keyword ':' space+ value eol</a></strong>

<dd>
<p>Meta statements are key/value pairs separated by a colon and whitespace. A
given meta setting may affect the document parsing from that point forward.</p>
</dd>
</li>
<dt><strong><a name="test_statement_data_transform_space_operator_space_data_transform_eol" class="item">test-statement := data-transform space+ operator space+ data-transform eol</a></strong>

<dd>
<p>A test statement is a declaration of a testing operation. A typical statement
looks like:</p>
</dd>
<dd>
<pre>
    input-name.transform1().transform2(arguments) == expected-output-name</pre>
</dd>
</li>
<dt><strong><a name="include_statement_include_space_relative_file_path_eol" class="item">include-statement := '%include' space+ relative-file-path eol</a></strong>

<dd>
<p>An include statement causes the named relative file to be read. The file
contents replace the include statement and are immediately parsed.</p>
</dd>
</li>
<dt><strong><a name="space_space_char_tab_char" class="item">space := SPACE-CHAR | TAB-CHAR</a></strong>

<dd>
<p>A <em>space</em> token is a normal space character or a tab character.</p>
</dd>
</li>
<dt><strong><a name="eol_space_carriage_return_newline" class="item">eol := space+ CARRIAGE-RETURN? NEWLINE</a></strong>

<dd>
<p>The <em>eol</em> token is a Unix or DOS line ending.</p>
</dd>
</li>
<dt><strong><a name="data_section_testml_data_section_yaml_data_section_json_data_section_xml_data_section" class="item">data-section := testml-data-section | yaml-data-section | json-data-section | xml-data-section</a></strong>

<dd>
<p>The data section defines a sequence of data objects, each of which consists of
a short description phrase and a set of named data points.</p>
</dd>
<dd>
<p>TestML defines a default syntax, but this section can also be specified in
YAML, JSON or XML.</p>
</dd>
</li>
<dt><strong><a name="testml_data_section_testml_data_block_marker_space_rest" class="item">testml-data-section := testml-data-block-marker space+ rest</a></strong>

<dd>
<p>The <em>TestML data section</em> starts when the data block marker is detected at
the beginning of a line and continues to the end of the file. This section is
parsed into <em>data block</em> objects.</p>
</dd>
<dd>
<p>Here is an example data section in TestML:</p>
</dd>
<dd>
<pre>
    === Test one
    --- input: abc
    --- output: 123
    === Test two
    --- input: xyz
    --- output: 321</pre>
</dd>
<dd>
<p>See <a href="#testml_data_section_grammar">TestML Data Section Grammar</a> for the more formal syntax grammar of
this format.</p>
</dd>
</li>
<dt><strong><a name="yaml_data_section_whitespace_rest" class="item">yaml-data-section :=  '---' whitespace rest</a></strong>

<dd>
<p>Here is an example data section in YAML:</p>
</dd>
<dd>
<pre>
    ---
    - __name__: Test one
      input: abc
      output: 123
    - __name__: Test two
      input: xyz
      output: 321</pre>
</dd>
</li>
<dt><strong><a name="json_data_section_rest" class="item">json-data-section :=  '[' rest</a></strong>

<dd>
<p>Here is an example data section in JSON:</p>
</dd>
<dd>
<pre>
    [
      {
        &quot;__name__&quot;: &quot;Test one&quot;,
        &quot;input&quot;: &quot;abc&quot;,
        &quot;output&quot;: &quot;123&quot;
      },
      {
        &quot;__name__&quot;: &quot;Test two&quot;,
        &quot;input&quot;: &quot;xyz&quot;,
        &quot;output&quot;: &quot;321&quot;
      }
    ]</pre>
</dd>
</li>
<dt><strong><a name="xml_data_section_rest" class="item">xml-data-section :=  '&lt;' rest</a></strong>

<dd>
<pre>
    &lt;testml&gt;
      &lt;block name=&quot;Test one&quot;&gt;
        &lt;input&gt;abc&lt;/input&gt;
        &lt;output&gt;123&lt;/output&gt;
      &lt;/block&gt;
      &lt;block name=&quot;Test two&quot;&gt;
        &quot;input&quot;: &quot;xyz&quot;,
        &quot;output&quot;: &quot;321&quot;
      &lt;/block&gt;
    &lt;/testml&gt;</pre>
</dd>
<dt><strong><a name="rest_any_char" class="item">rest := ANY-CHAR+</a></strong>

<dd>
<p>The <em>rest</em> token is simply the remainder of the text in the file. The <em>data
sections</em> are all parsed by separate parsers/grammars.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="testml_data_section_grammar">TestML Data Section Grammar</a></h2>
<dl>
<dt><strong><a name="data_section_data_block" class="item">data-section := data-block*</a></strong>

<dt><strong><a name="data_block_block_header_line_data_point" class="item">data-block := block-header line* data-point*</a></strong>

<dt><strong><a name="block_header_block_marker_space_block_name_eol" class="item">block-header := block-marker space+ block-name eol</a></strong>

<dt><strong><a name="data_point_lines_point_phrase_point" class="item">data-point := lines-point | phrase-point</a></strong>

<dt><strong><a name="lines_point_point_marker_point_name_eol_line" class="item">lines-point := point-marker point-name eol line*</a></strong>

<dt><strong><a name="phrase_point_point_marker_point_name_space_non_break_char_eol" class="item">phrase-point := point-marker point-name ':' space+ NON-BREAK-CHAR* eol</a></strong>

<dt><strong><a name="line_non_break_char_eol" class="item">line := NON-BREAK-CHAR* eol</a></strong>

</dl>
<p>
</p>
<hr />
<h1><a name="authors">Authors</a></h1>
<p>TestML Version 1.0 was created by Ingy döt Net &lt;<a href="mailto:ingy@ingy.net">ingy@ingy.net</a>&gt;</p>
<p>
</p>
<hr />
<h1><a name="copyright">Copyright</a></h1>
<p>Copyright (c) 2009. Ingy döt Net.</p>
<p>This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.</p>
<p>See <a href="http://www.perl.com/perl/misc/Artistic.html">http://www.perl.com/perl/misc/Artistic.html</a></p>


  </body>
</html>

